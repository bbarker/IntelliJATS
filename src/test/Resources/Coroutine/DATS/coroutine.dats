// What a test
#include "A.h"
/**************************************************************************
 *                        Start cleaning up                               *
 **************************************************************************/
void main() {
  warn(1,1,1,1);
  warn(1,1,1,1);
  a->*bbb(aaa[1]);
  if (true) {
    cout << errr << flush;
  }
  warn(1,1,1,1);
}

static STLInfo g_stlinfo[] =
{
  // className              baseClass1                      baseClass2             templType1     templName1     templType2    templName2     virtInheritance  // iterators
  { "overflow_error",       "runtime_error",                0,                     0,             0,             0,            0,             FALSE,              FALSE },
  { "underflow_error",      "runtime_error",                0,                     0,             0,             0,            0,             FALSE,              FALSE },
  { 0,                      0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }
};

#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
	&& (defined (__STDC__) || defined (__cplusplus)))
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
# elif (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
	&& (defined (__STDC__) || defined (__cplusplus)))
void *malloc (size_t); /* INFRINGES ON USER NAME SPACE */
#   endif

static void main(const char* p) {
  int a = 1;
}

void aaa();
void bbb() {};

#ifdef HAS_SIGNALS
static void stopGen(int)
{
  exit(1);
}
#endif

# \

# define W(name,default)				\
  if (Str::eq (real_name, #name))			\
    project -> options -> warnings.name = state;	\
  else
WARNINGS_LIST
# undef W

class A {
  A &operator=(const A &);
  A &operator ==(const A &);
  ~A();
};
